# Test info

- Name: Verify item visibility in CSR search
- Location: M:\PlaywrightStuff\src\tests\search.test.ts:9:5

# Error details

```
TimeoutError: locator.waitFor: Timeout 10000ms exceeded.
Call log:
  - waiting for locator('iframe[name="itemscope"]').contentFrame().getByRole('option', { name: 'Online' }) to be visible

    at selectOnlineOption (M:\PlaywrightStuff\src\pages\ItemPage.ts:87:26)
    at ItemPage.changeStatusToOnline (M:\PlaywrightStuff\src\pages\ItemPage.ts:93:11)
    at M:\PlaywrightStuff\src\tests\search.test.ts:25:9
    at M:\PlaywrightStuff\src\tests\search.test.ts:17:28
```

# Test source

```ts
   1 | import { Page, Locator, expect } from '@playwright/test';
   2 | import type { FrameLocator } from '@playwright/test';
   3 | import { BasePage } from './basePage';
   4 |
   5 | export class ItemPage extends BasePage {
   6 |   readonly frame: FrameLocator;
   7 |   readonly saveButton: Locator;
   8 |   readonly notificationDialog: Locator;
   9 |   readonly updateButton: Locator;
   10 |   readonly itemtitle: Locator;
   11 |   readonly successNotification = this.page.locator('.save-success');
   12 | readonly savingIndicator = this.page.locator('.saving-indicator');
   13 |
   14 |   constructor(page: Page) {
   15 |     super(page);
   16 |     this.itemtitle = page.locator('#itemTitleForEdit');
   17 |     this.frame = this.getFrame('iframe[name="itemscope"]');
   18 |     this.saveButton = page.getByRole('button', { name: 'Save', exact: true });
   19 |     this.notificationDialog = page.locator('[aria-describedby="notification-dialog"]');
   20 |     this.updateButton = page.getByRole('button', { name: 'Update' });
   21 |   }
   22 |
   23 |   async openitemtab(): Promise<void> {
   24 |     await this.page.locator('iframe[name="itemscope"]').contentFrame().getByRole('link', { name: '1' }).click();
   25 |   }
   26 |
   27 |   async addimagetoexternalfield(): Promise<void> {
   28 |     await this.page.locator('iframe[name="itemscope"]').contentFrame().locator('#item-update-tab-1 div').filter({ hasText: 'Browse' }).nth(4).click();
   29 |     await this.page.locator('div').filter({ hasText: /^download045\.jpeg$/ }).first().click();
   30 |     await this.page.getByRole('button', { name: 'Select file' }).click();
   31 |   }
   32 |
   33 |   async checkaddedimagetoexternalfield(): Promise<void> {
   34 |     const frame = this.page.frameLocator('iframe[name="itemscope"]');
   35 |     const img = frame.locator('.file-widget-preview-thumbnail[src*="b6e0bfe5-a305-40c2-9b74-d81d80bf5f5f"]');
   36 |     await expect(img).toHaveAttribute(
   37 |       'src',
   38 |       'https://kmsqacm.lighthouse-cloud.com:443/kms/lh/archive/externalFiles/b6e0bfe5-a305-40c2-9b74-d81d80bf5f5f.jpeg');
   39 |   }
   40 |
   41 |   async fillItemName(name: string): Promise<string> {
   42 |     const uniqueId = Date.now();
   43 |     const entityName = `${name} ${uniqueId}`;
   44 |     await this.frame.getByRole('heading', { name: 'New Item' }).click();
   45 |     await this.frame.locator('input[name="inplace_value"]').fill(entityName);
   46 |     console.log(`Created entity: ${entityName}`);
   47 |     return entityName;
   48 |   }
   49 |
   50 |   async fillOnlineItemName(): Promise<string> {
   51 |     return this.fillItemName('Online Item');
   52 |   }
   53 |
   54 |   async fillOfflineItemName(): Promise<string> {
   55 |     return this.fillItemName('Offline Item');
   56 |   }
   57 |
   58 |   async changeStatusToOnline(): Promise<void> {
   59 |     const frame = this.page.frameLocator('iframe[name="itemscope"]');
   60 |
   61 |     const clickOfflineWithRetry = async (maxRetries = 5) => {
   62 |       for (let attempt = 1; attempt <= maxRetries; attempt++) {
   63 |         try {
   64 |           console.log(`Attempt ${attempt} to click Offline`);
   65 |           await frame.locator('body').waitFor({ state: 'attached' });
   66 |           const offlineElement = frame.locator('.selection-container');
   67 |           await offlineElement.waitFor({ state: 'visible', timeout: 5000 });
   68 |           await expect(offlineElement).toBeEnabled();
   69 |           //await expect(offlineElement).not.toHaveClass(/disabled/);
   70 |           await expect(offlineElement).not.toHaveAttribute('aria-disabled', 'true');
   71 |           await offlineElement.scrollIntoViewIfNeeded();
   72 |           await offlineElement.hover();
   73 |
   74 |           await offlineElement.click({ force: true, trial: true, delay: 200 });
   75 |           await frame.locator('.iw-dropdown-filter-container').waitFor({ state: 'visible', timeout: 5000 });
   76 |           return;
   77 |         } catch (error) {
   78 |           console.warn(`Attempt ${attempt} failed:`, error instanceof Error ? error.message : String(error));
   79 |           await this.wait(1000);
   80 |           if (attempt === maxRetries) throw error;
   81 |         }
   82 |       }
   83 |     };
   84 |
   85 |     const selectOnlineOption = async () => {
   86 |       const onlineOption = frame.getByRole('option', { name: 'Online' });
>  87 |       await onlineOption.waitFor({ state: 'visible', timeout: 10000 });
      |                          ^ TimeoutError: locator.waitFor: Timeout 10000ms exceeded.
   88 |       await onlineOption.click({ force: true, timeout: 5000, trial: true });
   89 |       await frame.locator('#status-select').waitFor({ state: 'visible', timeout: 10000 });
   90 |     };
   91 |
   92 |     await clickOfflineWithRetry();
   93 |     await selectOnlineOption();
   94 |     await this.screenshot('after-status-change');
   95 |   }
   96 |
   97 |   async saveAndHandleDialog(): Promise<void> {
   98 |     // 1. Ожидаем стабильности перед сохранением
   99 |     await this.page.waitForLoadState('networkidle');
  100 |     //await this.wait(1000); // Дополнительная пауза
  101 |
  102 |     // 2. Убедимся, что кнопка действительно кликабельна
  103 |     await this.expectToBeVisible(this.saveButton, 15000);
  104 |     await this.expectToBeEnabled(this.saveButton);
  105 |     
  106 |     // 3. Клик с расширенной обработкой
  107 |     await this.clickWithRetry(this.saveButton, {
  108 |         maxRetries: 5, // Увеличили количество попыток
  109 |         timeout: 15000,
  110 |         preAction: async () => {
  111 |             await this.forceBlur();
  112 |             await this.wait(500);
  113 |         }
  114 |     });
  115 |
  116 |     // 4. Ожидаем либо диалог, либо успешное сохранение
  117 |     try {
  118 |         await this.notificationDialog.waitFor({ state: 'visible', timeout: 2000 });
  119 |         await this.click(this.updateButton, { timeout: 2000 });
  120 |         console.log('Closed notification dialog');
  121 |     } catch (error) {
  122 |         console.log('Notification dialog did not appear');
  123 |     }
  124 |
  125 |     
  126 | }
  127 |
  128 |   private async forceBlur(): Promise<void> {
  129 |     await this.page.evaluate(() => {
  130 |       const active = document.activeElement as HTMLElement;
  131 |       if (active) active.blur();
  132 |     });
  133 |
  134 |     await this.page.waitForTimeout(500); // Краткая пауза
  135 |   }
  136 |
  137 |   async verifyItemInTree(itemName: string): Promise<void> {
  138 |     const itemInTree = this.page.locator(`[role="button"][title="${itemName}"]`)
  139 |       .or(this.page.locator(`.dynatree-title:has-text("${itemName}")`))
  140 |       .first();
  141 |     await this.expectToBeVisible(itemInTree, 15000);
  142 |   }
  143 |
  144 |   async verifyStatusOnline(): Promise<void> {
  145 |     const statusText = this.frame.locator('.iw-dropdown-value-container .selection-container span');
  146 |     await this.expectToHaveText(statusText, /^Online$/);
  147 |
  148 |   }
  149 |
  150 |   async verifyOnlineItemColor(itemName: string): Promise<void> {
  151 |     const button = this.page.locator(`[role="button"][title="${itemName}"]`)
  152 |       .or(this.page.locator(`.dynatree-title:has-text("${itemName}")`))
  153 |       .or(this.page.getByRole('button', { name: itemName }))
  154 |       .first();
  155 |
  156 |     await this.expect(button).toBeVisible({ timeout: 15000 }); // Исправлено здесь
  157 |
  158 |     const elementInfo = await button.evaluate(el => ({
  159 |       color: getComputedStyle(el).color,
  160 |       backgroundColor: getComputedStyle(el).backgroundColor
  161 |     }));
  162 |
  163 |     console.log('Цвет Online элемента:', elementInfo.color);
  164 |
  165 |     const actualColor = elementInfo.color;
  166 |     if (!(actualColor === 'rgb(10, 12, 13)' ||
  167 |       actualColor === '#0a0c0d' ||
  168 |       actualColor.toLowerCase().includes('0a0c0d'))) {
  169 |       await this.page.screenshot({ path: 'online-color-error.png' });
  170 |       throw new Error(`Некорректный цвет Online элемента. Ожидался 0a0c0d, получен: ${actualColor}`);
  171 |     }
  172 |   }
  173 |
  174 |   async verifyStatusOffline(): Promise<void> {
  175 |     const statusText = this.frame.locator('.iw-dropdown-value-container .selection-container span');
  176 |     await this.expectToHaveText(statusText, /^Offline$/);
  177 |   }
  178 |
  179 |   async verifyOfflineItemColor(itemName: string): Promise<void> {
  180 |     const button = this.page.locator(`[role="button"][title="${itemName}"]`)
  181 |       .or(this.page.locator(`.dynatree-title:has-text("${itemName}")`))
  182 |       .or(this.page.getByRole('button', { name: itemName }))
  183 |       .first();
  184 |
  185 |     await expect(button).toBeVisible({ timeout: 15000 });
  186 |
  187 |     const elementInfo = await button.evaluate(el => ({
```